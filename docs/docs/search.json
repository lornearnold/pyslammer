[
  {
    "objectID": "reference/motion.html",
    "href": "reference/motion.html",
    "title": "motion",
    "section": "",
    "text": "motion\nmotion"
  },
  {
    "objectID": "reference/FT3_TO_IN3.html",
    "href": "reference/FT3_TO_IN3.html",
    "title": "FT3_TO_IN3",
    "section": "",
    "text": "FT3_TO_IN3\nFT3_TO_IN3"
  },
  {
    "objectID": "reference/da.html",
    "href": "reference/da.html",
    "title": "da",
    "section": "",
    "text": "da\nda"
  },
  {
    "objectID": "reference/KNM3_TO_LBFT3.html",
    "href": "reference/KNM3_TO_LBFT3.html",
    "title": "KNM3_TO_LBFT3",
    "section": "",
    "text": "KNM3_TO_LBFT3\nKNM3_TO_LBFT3"
  },
  {
    "objectID": "reference/M_TO_CM.html",
    "href": "reference/M_TO_CM.html",
    "title": "M_TO_CM",
    "section": "",
    "text": "M_TO_CM\nM_TO_CM"
  },
  {
    "objectID": "reference/mod_damp_testing.html",
    "href": "reference/mod_damp_testing.html",
    "title": "mod_damp_testing",
    "section": "",
    "text": "mod_damp_testing\nmod_damp_testing(effective_strain, ref_strain)"
  },
  {
    "objectID": "reference/sample_ground_motions.html",
    "href": "reference/sample_ground_motions.html",
    "title": "sample_ground_motions",
    "section": "",
    "text": "sample_ground_motions\nsample_ground_motions()"
  },
  {
    "objectID": "reference/ca.html",
    "href": "reference/ca.html",
    "title": "ca",
    "section": "",
    "text": "ca\nca"
  },
  {
    "objectID": "reference/ky_func.html",
    "href": "reference/ky_func.html",
    "title": "ky_func",
    "section": "",
    "text": "ky_func\nky_func"
  },
  {
    "objectID": "reference/GAMMA.html",
    "href": "reference/GAMMA.html",
    "title": "GAMMA",
    "section": "",
    "text": "GAMMA\nGAMMA"
  },
  {
    "objectID": "reference/Decoupled.html",
    "href": "reference/Decoupled.html",
    "title": "Decoupled",
    "section": "",
    "text": "Decoupled\nDecoupled(\n    self,\n    ky,\n    a_in,\n    dt,\n    height,\n    vs_slope,\n    vs_base,\n    damp_ratio,\n    ref_strain,\n    scale_factor=1,\n    soil_model='linear_elastic',\n    si_units=True,\n    lite=False,\n)"
  },
  {
    "objectID": "reference/BETA.html",
    "href": "reference/BETA.html",
    "title": "BETA",
    "section": "",
    "text": "BETA\nBETA"
  },
  {
    "objectID": "reference/M3_TO_CM3.html",
    "href": "reference/M3_TO_CM3.html",
    "title": "M3_TO_CM3",
    "section": "",
    "text": "M3_TO_CM3\nM3_TO_CM3"
  },
  {
    "objectID": "reference/equivalent_linear_testing.html",
    "href": "reference/equivalent_linear_testing.html",
    "title": "equivalent_linear_testing",
    "section": "",
    "text": "equivalent_linear_testing\nequivalent_linear_testing"
  },
  {
    "objectID": "reference/damping.html",
    "href": "reference/damping.html",
    "title": "damping",
    "section": "",
    "text": "damping\ndamping"
  },
  {
    "objectID": "reference/strains.html",
    "href": "reference/strains.html",
    "title": "strains",
    "section": "",
    "text": "strains\nstrains"
  },
  {
    "objectID": "reference/some_ky_func.html",
    "href": "reference/some_ky_func.html",
    "title": "some_ky_func",
    "section": "",
    "text": "some_ky_func\nsome_ky_func(disp)"
  },
  {
    "objectID": "reference/LBFT3_TO_KNM3.html",
    "href": "reference/LBFT3_TO_KNM3.html",
    "title": "LBFT3_TO_KNM3",
    "section": "",
    "text": "LBFT3_TO_KNM3\nLBFT3_TO_KNM3"
  },
  {
    "objectID": "reference/impedance_damping.html",
    "href": "reference/impedance_damping.html",
    "title": "impedance_damping",
    "section": "",
    "text": "impedance_damping\nimpedance_damping(vs_base, vs_slope)"
  },
  {
    "objectID": "reference/ky_interp.html",
    "href": "reference/ky_interp.html",
    "title": "ky_interp",
    "section": "",
    "text": "ky_interp\nky_interp"
  },
  {
    "objectID": "reference/csv_time_hist.html",
    "href": "reference/csv_time_hist.html",
    "title": "csv_time_hist",
    "section": "",
    "text": "csv_time_hist\ncsv_time_hist(filename)\nRead a CSV file containing time history acceleration data and return a 1D numpy array and a timestep\nReturns: a_in: A 1D numpy array containing time history data. dt: The timestep of the data."
  },
  {
    "objectID": "reference/interpolated_k_y.html",
    "href": "reference/interpolated_k_y.html",
    "title": "interpolated_k_y",
    "section": "",
    "text": "interpolated_k_y\ninterpolated_k_y(k_y)"
  },
  {
    "objectID": "reference/darendelli.html",
    "href": "reference/darendelli.html",
    "title": "darendelli",
    "section": "",
    "text": "darendelli\ndarendelli"
  },
  {
    "objectID": "rigid_flex.html",
    "href": "rigid_flex.html",
    "title": "Rigid and Flexible Anlysis",
    "section": "",
    "text": "This notebook shows an example use case of pyslammer for running rigid, decoupled, and coupled sliding block analyses.\nThe next steps assume you’ve already installed pySLAMMER from PYPI:\nFirst, import pySLAMMER and a couple other helpful packages\nimport pyslammer as slam\nimport numpy as np\nimport matplotlib.pyplot as plt\nNext define the ground motion to use in the analysis. For this example, we will use one of pySLAMMER’s built in ground motions from the 1995 Kobe earthquake. This creates a ground motion object with accel and dt attributes with the acceleration array and timestep, respectively.\nrecord_name = \"Kobe_1995_TAK-090\"\ngm = slam.sample_ground_motions()[record_name]",
    "crumbs": [
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "rigid_flex.html#rigid-block-analysis",
    "href": "rigid_flex.html#rigid-block-analysis",
    "title": "Rigid and Flexible Anlysis",
    "section": "Rigid block analysis",
    "text": "Rigid block analysis\nA rigid block analysis requires at least three input parameters:\n\na_in - the input acceleration time history (in units of g)\ndt - the timestep separating the acceleration data points\nky - the slope’s yield acceleration (in units of g)\n\nThese parameters are stored in a dictionary (rigid_inputs) and used as kwarg input to the RigidAnalysis method.\n\nrigid_inputs = {\n    \"a_in\": gm.accel,\n    \"dt\": gm.dt,\n    \"ky\": 0.2\n}\nprint(rigid_inputs)\n\nrigid_result = slam.RigidAnalysis(**rigid_inputs, scale_factor=2)\n\n{'a_in': array([ 1.36409e-04,  7.44843e-05, -2.41948e-06, ..., -3.40833e-04,\n       -3.29109e-04, -3.24053e-04], shape=(4015,)), 'dt': 0.01, 'ky': 0.2}\n\n\n\n\n\n\n\n\nNote\n\n\n\nPassing the input variables to slam.RigidAnalysis as a dictionary isn’t necessary, it’s just a convenient way to package groups of input variables. The following line would have produced the same result as the previous cell:\nrigid_result = slam.RigidAnalysis(gm.accel, gm.dt, 0.2)",
    "crumbs": [
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "rigid_flex.html#flexible-sliding-block-analysis",
    "href": "rigid_flex.html#flexible-sliding-block-analysis",
    "title": "Rigid and Flexible Anlysis",
    "section": "Flexible sliding block analysis",
    "text": "Flexible sliding block analysis\nThe flexible block analyses (decoupled and coupled) require additional input parameters to define the stiffness of the model:\n\nheight - the slope height (in meters, by default)\nvs_slope - the slope shear wave velocity (in meters per second, by default)\nvs_base - the base shear wave velocity (in meters per second, by default)\ndamp_ratio - the slope damping ratio\nref_strain - the slope reference strain\nsoil_model - the dynamic analysis method used (either linear_elastic or equivalent_linear)\n\nThese parameters are stored in a dictionary (flexible_inputs) and used as kwargs along with those used in the rigid analysis. The decoupled and coupled analyses are run with the Decoupled and Coupled methods, respectively.\n\nflexible_inputs = {\n    \"height\": 50.0,\n    \"vs_slope\": 600.0,\n    \"vs_base\": 600.0,\n    \"damp_ratio\": 0.05,\n    \"ref_strain\": 0.0005,\n    \"soil_model\": \"equivalent_linear\"\n}\n\ndecoupled_result = slam.Decoupled(**rigid_inputs,**flexible_inputs)\ndecoupled_result._compile_attributes()\ncoupled_result = slam.Coupled(**rigid_inputs,**flexible_inputs)\ncoupled_result._compile_attributes()",
    "crumbs": [
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "rigid_flex.html#comparison-of-analysis-methods",
    "href": "rigid_flex.html#comparison-of-analysis-methods",
    "title": "Rigid and Flexible Anlysis",
    "section": "Comparison of analysis methods",
    "text": "Comparison of analysis methods\nA simple plot comparing the block displacements with time can be generated by accessing the .sliding_disp attribute of each analysis result.\n\nplt.figure(figsize=(10, 6))\n\ntime = np.arange(0, len(gm.accel) * gm.dt, gm.dt)\n\n# Plot block displacement vs time for each analysis method\nplt.plot(time, rigid_result.sliding_disp, label='Rigid Analysis')\nplt.plot(time, decoupled_result.sliding_disp, label='Decoupled Analysis')\nplt.plot(time, coupled_result.sliding_disp, label='Coupled Analysis')\n\n# Add labels and legend\nplt.xlabel('Time (s)')\nplt.ylabel('Block Displacement (m)')\nplt.title(f'Block Displacement with Different Analysis Methods\\n for {record_name}')\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nrigid_fig = rigid_result.sliding_block_plot()\ndecoupled_fig = decoupled_result.sliding_block_plot()\ncoupled_fig = coupled_result.sliding_block_plot()",
    "crumbs": [
      "Examples",
      "Rigid and Flexible Anlysis"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pySLAMMER",
    "section": "",
    "text": "pySLAMMER (Python package for Seismic Landslide Movement Modeled using Earthquake Records) is tool for estimating the co-seismic displacements of landslides with rigid and flexible sliding-block analyses. The package name and code are based on the USGS tool SLAMMER by R. Jibson et al. (2013).\npySLAMMER includes the following sliding block models:\n\nRigid (i.e., traditional Newmark analysis (Newmark 1965) as implemented by R. W. Jibson and Keefer (1993)).\nDecoupled (per Makdisi and Seed (1978))\nCoupled (described by Chopra and Zhang (1991) and modified by Rathje and Bray (1999))",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#welcome-to-pyslammers-documentation",
    "href": "index.html#welcome-to-pyslammers-documentation",
    "title": "pySLAMMER",
    "section": "",
    "text": "pySLAMMER (Python package for Seismic Landslide Movement Modeled using Earthquake Records) is tool for estimating the co-seismic displacements of landslides with rigid and flexible sliding-block analyses. The package name and code are based on the USGS tool SLAMMER by R. Jibson et al. (2013).\npySLAMMER includes the following sliding block models:\n\nRigid (i.e., traditional Newmark analysis (Newmark 1965) as implemented by R. W. Jibson and Keefer (1993)).\nDecoupled (per Makdisi and Seed (1978))\nCoupled (described by Chopra and Zhang (1991) and modified by Rathje and Bray (1999))",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "pySLAMMER",
    "section": "Contents",
    "text": "Contents\nQuickstart guide\nExamples\nAPI Reference\nVerification",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "Examples\nI want to try to include a toctree here, but I’m not sure if it will work. That seems like something quarto should be able to do: reference index files for different sections and have their table of contents show up within the sidebar without needing to update it in two places."
  },
  {
    "objectID": "verification.html",
    "href": "verification.html",
    "title": "Verification",
    "section": "",
    "text": "Verification\nAdditionally, where available, analytical solutions provide another point verification. While analytical solutions to sliding block analyses are not possible for complex ground motions, they can be developed for simple harmonic motions and pulses Conte and Dente (1989).\nThe following sections compare pySLAMMER’s results to the legacy SLAMMER program results for a suite of recorded ground motions as well as analytical results for harmonic ground motions. For equivalent linear options for coupled analysis, the computational performance of pySLAMMER and SLAMMER are also compared.\n\n\n\n\n\nReferences\n\nConte, Enrico, and Giovanni Dente. 1989. “An Analytical Solution for Newmark’s Sliding Block.” Soils and Foundations 29 (3): 152–56. https://doi.org/10.3208/sandf1972.29.3_152.",
    "crumbs": [
      "Verifications"
    ]
  },
  {
    "objectID": "batch_simulations.html",
    "href": "batch_simulations.html",
    "title": "Batch Simulations",
    "section": "",
    "text": "This notebook shows an example use case of pyslammer for running batch simulations.",
    "crumbs": [
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "batch_simulations.html#setup",
    "href": "batch_simulations.html#setup",
    "title": "Batch Simulations",
    "section": "Setup",
    "text": "Setup\nAssumes pyslammer is installed in the current python environment. Documentation on installation pending, but for now, you can install it using pip:\npip install pyslammer\nImport pyslammer using:\n\nimport pyslammer as slam\n\nAdditional Python libraries, such as matplotlib may also be useful.\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nplt.style.use(slam.psfigstyle)\n\n\nkys = np.linspace(0.01,0.3,20)\nhistories = slam.sample_ground_motions()\noutput = {}",
    "crumbs": [
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "batch_simulations.html#comparing-multiple-motions",
    "href": "batch_simulations.html#comparing-multiple-motions",
    "title": "Batch Simulations",
    "section": "Comparing multiple motions",
    "text": "Comparing multiple motions\nThe results of the analyses can be plotted to show trends in total accumulated displacement with \\(k_y\\) for each ground motion in the sample ground motion suite.\n\nplt.close('all')\nfig, ax = plt.subplots()\n# fig.set_size_inches(10,6)   \nfor key, grp in df.groupby(['motion']):\n    ax.scatter(grp[\"ky\"]/grp[\"k_max\"], grp[\"d_max\"], label=key[0], alpha=0.5)\nax.legend(loc='upper left', bbox_to_anchor=(1, 1))\nax.set_xlim(0,1)\nax.set_yscale('log')\nax.set_ylim(1e-3,1e1)\nax.set_xlabel('$k_y / k_{max}$')\nax.set_ylabel('Maximum Displacement (m)')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nVariation in final displacement with \\(k_y\\) for the sample ground motion suite.",
    "crumbs": [
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "batch_simulations.html#variation-in-a-single-motions-time-history",
    "href": "batch_simulations.html#variation-in-a-single-motions-time-history",
    "title": "Batch Simulations",
    "section": "Variation in a single motion’s time history",
    "text": "Variation in a single motion’s time history\nAlternatively, for any given motion, the displacement time histories for different values of \\(k_y\\) could be of interest. In Figure @fig_variation_single, the results from all the simulations with the Imperial_Valley_1979_BCR-230 motion are shown. Although a different dimension of the data are being shown, the figure is simply pulling from the the results dataframe used in @fig_multi_motion.\n\n\nCode\nimport matplotlib.cm as cm\nfrom matplotlib.colors import LogNorm\n\nmotion = \"Imperial_Valley_1979_BCR-230\"\n\nplt.close('all')\n\n# Create a figure and axes\nfig, ax = plt.subplots(figsize=(6, 4))\n\n# Create a color map\ncmap = plt.colormaps['Spectral']#cm.get_cmap('viridis')\nnorm = LogNorm(df['ky'].min(), df['ky'].max())\n\ndt = df[df[\"motion\"]==motion].iloc[0]['dt']\nnpts = df[df[\"motion\"]==motion].iloc[0]['disp'].shape[0]\ntime = np.linspace(0, dt*npts, npts)\n\nfor index, row in df[df[\"motion\"]==motion].iterrows():\n    color = cmap(norm(row['ky']))\n    ax.plot(time, row['disp'], color=color)\n\n# Add a color bar\nsm = cm.ScalarMappable(cmap=cmap, norm=norm)\nsm.set_array([])\ncbar = fig.colorbar(sm, ax=ax, label='ky')\n\n# Set the colorbar ticks and labels\nticks = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]\ncbar.set_ticks(ticks)\ncbar.set_ticklabels([f'{tick:.2f}' for tick in ticks]) \n\n# Set the x-axis and y-axis labels\nax.set_xlabel('Time')\nax.set_ylabel('Displacement')\nax.set_title(motion)\nplt.show()\n\n\n\n\n\nVariation in cumulative displacement with \\(k_y\\) for the Imperial Valley motion.",
    "crumbs": [
      "Examples",
      "Batch Simulations"
    ]
  },
  {
    "objectID": "quickstart.html",
    "href": "quickstart.html",
    "title": "Quickstart guide",
    "section": "",
    "text": "The pyslammer package is built on Python 3.12. Earlier versions of Python 3 may work, but have not been tested.",
    "crumbs": [
      "Quickstart guide"
    ]
  },
  {
    "objectID": "quickstart.html#requirements",
    "href": "quickstart.html#requirements",
    "title": "Quickstart guide",
    "section": "",
    "text": "The pyslammer package is built on Python 3.12. Earlier versions of Python 3 may work, but have not been tested.",
    "crumbs": [
      "Quickstart guide"
    ]
  },
  {
    "objectID": "quickstart.html#installation-using-pip",
    "href": "quickstart.html#installation-using-pip",
    "title": "Quickstart guide",
    "section": "Installation using pip",
    "text": "Installation using pip\n \nInstall pyslammer using pip from the Python Package Index (PyPI):\npip install pyslammer",
    "crumbs": [
      "Quickstart guide"
    ]
  },
  {
    "objectID": "quickstart.html#basic-usage",
    "href": "quickstart.html#basic-usage",
    "title": "Quickstart guide",
    "section": "Basic Usage",
    "text": "Basic Usage\nWith pyslammer installed, basic usage involves the following steps: 1. Import the pyslammer module 2. Import a ground motion 3. Perform a rigid sliding block analysis 4. View results\n\nImport the pyslammer module\nThe recommended ailas for pyslammer is slam:\n\nimport pyslammer as slam \n\nThis allows use of pyslammer features within your code with the short prefix slam.\nThe primary object type within pyslammer is the SlidingBlockAnalysis object. At a minimum any SlidingBlockAnalysis requires a yield acceleration for the slope (\\(k_y\\)) and an input ground motion. As basic example, consider a rigid sliding block analysis on a slope with a yield acceleration of \\(0.2\\) g.\n\n\nImport a ground motion\nA small number of sample ground motion records are included with pyslammer. We will use one of the sample ground motion records, but we expect most users will import their ground motions from external sources. To use any signal for a ground motion, pyslammer needs a 1-D array of acceleration in units of \\(g\\) and the signal timestep (in seconds). See The available sample ground motions can be viewed with:\n\nmotions = slam.sample_ground_motions() # Load all sample ground motions\nfor motion in motions:\n    print(motion)\n\nMorgan_Hill_1984_CYC-285\nNisqually_2001_UNR-058\nImperial_Valley_1979_BCR-230\nChi-Chi_1999_TCU068-090\nCape_Mendocino_1992_PET-090\nLoalinga_1983_PVB-045\nCoalinga_1983_PVB-045\nMammoth_Lakes-2_1980_CVK-090\nNorthridge_VSP-360\nKocaeli_1999_ATS-090\nNahanni_1985_NS1-280\nMammoth_Lakes-1_1980_CVK-090\nDuzce_1999_375-090\nLoma_Prieta_1989_HSP-000\nLanders_1992_LCN-345\nN_Palm_Springs_1986_WWT-180\nKobe_1995_TAK-090\nCoyote_Lake_1979_G02-050\n\n\nFor this example, we will use theImperial_Valley_1979_BCR-230 motion.\n\ngm = motions[\"Imperial_Valley_1979_BCR-230\"]\n\nThe timestep and acceleration signal for the imported ground motion are gm.dt and gm.accel, respectively.\n\n\nPerform a rigid sliding block analysis\nWith the imported ground motion, gm, and the assumed value of \\(k_y\\), we can perform a rigid sliding block analysis with pySLAMMER’s RigidAnalysis object. This simultaneously creates an instance of RigidAnalysis and performs the analysis, which is stored as result. The inputs for RigidAnalysis are the input acceleration signal, time step, and the yield acceleration.\nA note admonition! Not for anyting in particular, though...\n\nky = 0.2 # yield acceleration in g\nresult = slam.RigidAnalysis(ky, gm.accel, gm.dt)\n\n\n\nView results\nThe primary output of the sliding block analysis is the final displacement (SlidingBlockAnalysis.max_sliding_disp). By default, all lengths in pySLAMMER are in meters. The cell below shows the displacement induced by the sample ground motion in the example:\n\nprint(f\"Slope yield acc: {ky:.2f} g \\nGround motion: {gm.name}; PGA: {gm.pga:.2f} g \\nSliding displacement: {result.max_sliding_disp:.3f} m\")\n\nSlope yield acc: 0.20 g \nGround motion: Imperial_Valley_1979_BCR-230; PGA: 0.77 g \nSliding displacement: 0.213 m\n\n\nA built-in plotting function presents an at-a-glance picture of the analysis result in terms of the input motion and block accelerations, sliding velocity, and sliding displacement:\n\nfig = result.sliding_block_plot()\n\n\n\n\nRigid sliding block analysis results\n\n\n\n\nIn addition to the final displacement, the displacement, velocity, and acceleration time histories of the block are returned as numpy arrays. See the documentation for the SlidingBlockAnalysis class for a detailed description of all the results.",
    "crumbs": [
      "Quickstart guide"
    ]
  },
  {
    "objectID": "reference/RigidAnalysis.html",
    "href": "reference/RigidAnalysis.html",
    "title": "RigidAnalysis",
    "section": "",
    "text": "RigidAnalysis(self, a_in, dt, ky, method='jibson')\nRigid Block Analysis\n\n\n\n\n\nName\nDescription\n\n\n\n\njibson\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method.\n\n\n\n\n\nRigidAnalysis.jibson()\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method."
  },
  {
    "objectID": "reference/RigidAnalysis.html#methods",
    "href": "reference/RigidAnalysis.html#methods",
    "title": "RigidAnalysis",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\njibson\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method.\n\n\n\n\n\nRigidAnalysis.jibson()\nCalculate the downslope rigid block displacement, differential velocity, and acceleration using the Jibson method."
  },
  {
    "objectID": "reference/G_EARTH.html",
    "href": "reference/G_EARTH.html",
    "title": "G_EARTH",
    "section": "",
    "text": "G_EARTH\nG_EARTH"
  },
  {
    "objectID": "reference/Coupled.html",
    "href": "reference/Coupled.html",
    "title": "Coupled",
    "section": "",
    "text": "Coupled\nCoupled(\n    self,\n    ky,\n    a_in,\n    dt,\n    height,\n    vs_slope,\n    vs_base,\n    damp_ratio,\n    ref_strain,\n    scale_factor=1,\n    soil_model='linear_elastic',\n    si_units=True,\n    lite=False,\n)"
  },
  {
    "objectID": "reference/SlidingBlockAnalysis.html",
    "href": "reference/SlidingBlockAnalysis.html",
    "title": "SlidingBlockAnalysis",
    "section": "",
    "text": "SlidingBlockAnalysis\nSlidingBlockAnalysis(self)"
  },
  {
    "objectID": "reference/input_acc.html",
    "href": "reference/input_acc.html",
    "title": "input_acc",
    "section": "",
    "text": "input_acc\ninput_acc"
  },
  {
    "objectID": "reference/FT_TO_M.html",
    "href": "reference/FT_TO_M.html",
    "title": "FT_TO_M",
    "section": "",
    "text": "FT_TO_M\nFT_TO_M"
  },
  {
    "objectID": "reference/record.html",
    "href": "reference/record.html",
    "title": "record",
    "section": "",
    "text": "record\n\n\n\n\n\nName\nDescription\n\n\n\n\nGroundMotion\nGround Motion Record.\n\n\n\n\n\nrecord.GroundMotion(self, accel, dt, name='None')\nGround Motion Record.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naccel\nnp.ndarray or list\nGround motion acceleration record in g.\nrequired\n\n\ndt\nfloat\nTime step of the record (s).\nrequired\n\n\nname\nstr\nName of the record (default is ‘None’).\n'None'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\naccel\nnp.ndarray\nGround motion acceleration record in g.\n\n\ndt\nfloat\nTime step of the record (s).\n\n\nname\nstr\nName of the record.\n\n\n_is_inverted\nbool\nTrue if the record is inverted.\n\n\n_is_scaled\nbool\nTrue if the record is scaled.\n\n\n_npts\nint\nNumber of points in the acceleration record.\n\n\npga\nfloat\nPeak ground acceleration in g.\n\n\nmean_period\nfloat\nMean period of the ground motion.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninvert\nInvert the ground motion.\n\n\nplot\nPlots desired ground motion parameters.\n\n\nscale\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\nuninvert\nUninverts the ground motion.\n\n\nunscale\nUnscales the ground motion.\n\n\n\n\n\nrecord.GroundMotion.invert()\nInvert the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrecord.GroundMotion.plot(\n    acc=True,\n    vel=True,\n    disp=True,\n    enable=True,\n    called=False,\n)\nPlots desired ground motion parameters.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nacc\nbool\nPlot acceleration.\nTrue\n\n\nvel\nbool\nPlot velocity.\nTrue\n\n\ndisp\nbool\nPlot displacement.\nTrue\n\n\nenable\nbool\nEnable plotting of ground parameters. Used if called from a RigidBlock object.\nTrue\n\n\ncalled\nbool\nTrue if called from a RigidBlock object.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nplt.figure\nFigure object if called from a RigidBlock object.\n\n\nax\nplt.axis\nAxis object if called from a RigidBlock object.\n\n\n\n\n\n\n\nrecord.GroundMotion.scale(pga=False, scale_factor=False)\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npga\nfloat\nDesired peak ground acceleration in g.\nFalse\n\n\nscale_factor\nfloat\nDesired scale factor.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrecord.GroundMotion.uninvert()\nUninverts the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrecord.GroundMotion.unscale()\nUnscales the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone"
  },
  {
    "objectID": "reference/record.html#classes",
    "href": "reference/record.html#classes",
    "title": "record",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nGroundMotion\nGround Motion Record.\n\n\n\n\n\nrecord.GroundMotion(self, accel, dt, name='None')\nGround Motion Record.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naccel\nnp.ndarray or list\nGround motion acceleration record in g.\nrequired\n\n\ndt\nfloat\nTime step of the record (s).\nrequired\n\n\nname\nstr\nName of the record (default is ‘None’).\n'None'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\naccel\nnp.ndarray\nGround motion acceleration record in g.\n\n\ndt\nfloat\nTime step of the record (s).\n\n\nname\nstr\nName of the record.\n\n\n_is_inverted\nbool\nTrue if the record is inverted.\n\n\n_is_scaled\nbool\nTrue if the record is scaled.\n\n\n_npts\nint\nNumber of points in the acceleration record.\n\n\npga\nfloat\nPeak ground acceleration in g.\n\n\nmean_period\nfloat\nMean period of the ground motion.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninvert\nInvert the ground motion.\n\n\nplot\nPlots desired ground motion parameters.\n\n\nscale\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\nuninvert\nUninverts the ground motion.\n\n\nunscale\nUnscales the ground motion.\n\n\n\n\n\nrecord.GroundMotion.invert()\nInvert the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrecord.GroundMotion.plot(\n    acc=True,\n    vel=True,\n    disp=True,\n    enable=True,\n    called=False,\n)\nPlots desired ground motion parameters.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nacc\nbool\nPlot acceleration.\nTrue\n\n\nvel\nbool\nPlot velocity.\nTrue\n\n\ndisp\nbool\nPlot displacement.\nTrue\n\n\nenable\nbool\nEnable plotting of ground parameters. Used if called from a RigidBlock object.\nTrue\n\n\ncalled\nbool\nTrue if called from a RigidBlock object.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nplt.figure\nFigure object if called from a RigidBlock object.\n\n\nax\nplt.axis\nAxis object if called from a RigidBlock object.\n\n\n\n\n\n\n\nrecord.GroundMotion.scale(pga=False, scale_factor=False)\nScale the ground motion using desired method. Does nothing if more than one method is selected.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npga\nfloat\nDesired peak ground acceleration in g.\nFalse\n\n\nscale_factor\nfloat\nDesired scale factor.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrecord.GroundMotion.uninvert()\nUninverts the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrecord.GroundMotion.unscale()\nUnscales the ground motion.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone"
  },
  {
    "objectID": "reference/ky_const.html",
    "href": "reference/ky_const.html",
    "title": "ky_const",
    "section": "",
    "text": "ky_const\nky_const"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "API Reference\nAPI reference for pySLAMMER\n\n\n\nrecord\n\n\n\nRigidAnalysis\nRigid Block Analysis",
    "crumbs": [
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#api-reference",
    "href": "reference/index.html#api-reference",
    "title": "Function reference",
    "section": "",
    "text": "API reference for pySLAMMER\n\n\n\nrecord\n\n\n\nRigidAnalysis\nRigid Block Analysis",
    "crumbs": [
      "API reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/mrd_testing.html",
    "href": "reference/mrd_testing.html",
    "title": "mrd_testing",
    "section": "",
    "text": "mrd_testing\nmrd_testing"
  },
  {
    "objectID": "reference/M_TO_FT.html",
    "href": "reference/M_TO_FT.html",
    "title": "M_TO_FT",
    "section": "",
    "text": "M_TO_FT\nM_TO_FT"
  },
  {
    "objectID": "reference/strain_mod_update.html",
    "href": "reference/strain_mod_update.html",
    "title": "strain_mod_update",
    "section": "",
    "text": "strain_mod_update\nstrain_mod_update(effective_strain, ref_strain)"
  },
  {
    "objectID": "reference/CM_TO_FT.html",
    "href": "reference/CM_TO_FT.html",
    "title": "CM_TO_FT",
    "section": "",
    "text": "CM_TO_FT\nCM_TO_FT"
  },
  {
    "objectID": "reference/strain_damp_update.html",
    "href": "reference/strain_damp_update.html",
    "title": "strain_damp_update",
    "section": "",
    "text": "strain_damp_update\nstrain_damp_update(g_over_gmax, shear_strain, ref_strain)"
  },
  {
    "objectID": "reference/k_y_testing.html",
    "href": "reference/k_y_testing.html",
    "title": "k_y_testing",
    "section": "",
    "text": "k_y_testing\nk_y_testing"
  },
  {
    "objectID": "reference/CM_TO_IN.html",
    "href": "reference/CM_TO_IN.html",
    "title": "CM_TO_IN",
    "section": "",
    "text": "CM_TO_IN\nCM_TO_IN"
  },
  {
    "objectID": "reference/t_step.html",
    "href": "reference/t_step.html",
    "title": "t_step",
    "section": "",
    "text": "t_step\nt_step"
  },
  {
    "objectID": "reference/constant_k_y.html",
    "href": "reference/constant_k_y.html",
    "title": "constant_k_y",
    "section": "",
    "text": "constant_k_y\nconstant_k_y(k_y)"
  },
  {
    "objectID": "reference/assign_k_y.html",
    "href": "reference/assign_k_y.html",
    "title": "assign_k_y",
    "section": "",
    "text": "assign_k_y\nassign_k_y(k_y)"
  },
  {
    "objectID": "reference/mod_reduction.html",
    "href": "reference/mod_reduction.html",
    "title": "mod_reduction",
    "section": "",
    "text": "mod_reduction\nmod_reduction"
  },
  {
    "objectID": "reference/FT_TO_IN.html",
    "href": "reference/FT_TO_IN.html",
    "title": "FT_TO_IN",
    "section": "",
    "text": "FT_TO_IN\nFT_TO_IN"
  },
  {
    "objectID": "reference/histories.html",
    "href": "reference/histories.html",
    "title": "histories",
    "section": "",
    "text": "histories\nhistories"
  },
  {
    "objectID": "verification.html#comparing-pyslammers-results-to-analytical-solutions",
    "href": "verification.html#comparing-pyslammers-results-to-analytical-solutions",
    "title": "Verification",
    "section": "",
    "text": "In addition to comparing to the legacy results from SLAMMER, it is also worth comparing pySLAMER’s results to analytical solutions to sliding block problems. n this section, we compare pySLAMMER’s calucated sliding desplacements for rigid sliding blocks for single cycle harmonic motions of frequencies ranging from 0.5 to 10 Hz to an analytical solution.",
    "crumbs": [
      "Verifications"
    ]
  },
  {
    "objectID": "results_comp_analytical.html",
    "href": "results_comp_analytical.html",
    "title": "Comparison with analytical solution",
    "section": "",
    "text": "In addition to comparing to the legacy results from SLAMMER, it is also worth comparing pySLAMMER’s results to analytical solutions to sliding block problems. In this section, we compare pySLAMMER’s calculated sliding displacements for rigid sliding blocks for single cycle harmonic motions of frequencies ranging from 0.5 to 10 Hz to an analytical solution.\n\n\nVoluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with analytical solution"
    ]
  },
  {
    "objectID": "results_comp_analytical.html#analytical-solution",
    "href": "results_comp_analytical.html#analytical-solution",
    "title": "Comparison with analytical solution",
    "section": "",
    "text": "Voluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with analytical solution"
    ]
  },
  {
    "objectID": "performance_comp_SLAMMER.html",
    "href": "performance_comp_SLAMMER.html",
    "title": "Comparison with SLAMMER (speed)",
    "section": "",
    "text": "Voluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.\n\n\nVoluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (speed)"
    ]
  },
  {
    "objectID": "performance_comp_SLAMMER.html#equivalent-linear-execution-time",
    "href": "performance_comp_SLAMMER.html#equivalent-linear-execution-time",
    "title": "Comparison with SLAMMER (speed)",
    "section": "",
    "text": "Voluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (speed)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html",
    "href": "results_comp_SLAMMER.html",
    "title": "Comparison with SLAMMER (results)",
    "section": "",
    "text": "PySLAMMER’s rigid, decoupled, and coupled analysis methods are intended to produce sliding block analysis results that match the legacy SLAMMER results. This is an important feature for sliding block displacements, which are used as a performance index (as opposed to providing a direct prediction of actual slope displacement) in practice. Equivalence with legacy results allows new results to be interpreted with reference to historical analyses and experience.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#rigid-analysis",
    "href": "results_comp_SLAMMER.html#rigid-analysis",
    "title": "Comparison with SLAMMER (results)",
    "section": "",
    "text": "Voluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#decoupled-analysis",
    "href": "results_comp_SLAMMER.html#decoupled-analysis",
    "title": "Comparison with SLAMMER (results)",
    "section": "",
    "text": "Voluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#coupled-analysis",
    "href": "results_comp_SLAMMER.html#coupled-analysis",
    "title": "Comparison with SLAMMER (results)",
    "section": "",
    "text": "Voluptate reprehenderit velit elit deserunt qui anim cillum aliqua exercitation exercitation proident fugiat ad nulla veniam quis excepteur ut. Proident est laboris aliquip enim minim qui mollit do elit nisi culpa aliquip. Deserunt duis commodo fugiat enim adipiscing cupidatat quis pariatur incididunt occaecat elit mollit mollit quis. Laboris commodo ex minim eu aliquip incididunt reprehenderit sint eiusmod.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#approach",
    "href": "results_comp_SLAMMER.html#approach",
    "title": "Comparison with SLAMMER (results)",
    "section": "Approach",
    "text": "Approach\nTo demonstrate pySLAMMER’s equivalence to SLAMMER, we performed several sliding block analyses across a broad parametric space. The three main categories of parameters studied were ground motion, analysis method, and analysis options.\n\nGround motion\nWe used the motions from pySLAMMER’s built-in sample ground motion suite at several scales to capture a reasonable breadth of the familiar key engineering ground motion characteristics (frequency, amplitude, and duration). The acceleration response spectra for the input motion suite are shown in Figure 1. Additional details on the ground motions are provided on the ground motion suite page.\n\n\nCode\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\nfolder_path = Path(current_dir).resolve().parents[0] / \"tests\" / \"pySLAMMER_suite_resp\"\ncsv_files = list(folder_path.glob(\"*.csv\"))\n\n# Read each CSV file into a DataFrame and store them in a list\nfreq_index = 0\nresp_index = 1\nspectra = {}\nfor csv_file in csv_files:\n    data = np.loadtxt(csv_file, delimiter=\",\", skiprows=2)\n    # convert response from cm/s^2 to g's\n    data[:, resp_index] = data[:, resp_index] / 981\n    spectra[csv_file.name.strip(\".csv\")] = data\n\n# Initialize the plot\nfig, ax = plt.subplots()\nax.set_prop_cycle(cycler(color=plt.cm.tab20.colors))\nfor motion in spectra:\n    ax.plot(\n        1/spectra[motion][:, freq_index],\n        spectra[motion][:, resp_index],\n        label=motion,\n        linewidth=0.5,\n    )\n\nax.text(0.012, 2.75, \"5% damping\")\n# Add labels, legend, and grid\nax.set_xlabel(\"Period (s)\")\nax.set_ylabel(\"Spectral Acceleration (g)\")\nax.set_title(\"Response Spectra\")\nax.set_xscale(\"log\")\nax.set_ylim(0,3)\nax.set_xlim(0.01,100)\n\nax.legend(\n    loc=\"center left\", \n    bbox_to_anchor=(0.6, 0.6), \n    fontsize=\"x-small\", \n    title=\"Ground Motion\", \n    title_fontsize=\"medium\",\n    frameon=False\n)\n\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: Acceleration response spectra for input ground motions\n\n\n\n\n\n\n\nAnalysis methods\nThe three rigorous analysis methods that SLAMMER performs are the Rigid, Decoupled, and Coupled methods. Each of these methods, which are briefly described below, are implemented in pySLAMMER and included in this comparison.\n\nRigid Block Analysis\n\nConceptualized by Whitman in 1963 and further developed by Newmark in 1965 (Marcuson (1994), Newmark (1965)), rigid block analysis models a potential landslide mass as a rigid mass on an inclined plane base with a perfectly plastic frictional interface. The rigid block motion matches the base motion exactly until the acceleration of the base exceeds some critical value (the yield acceleration, \\(k_y\\)). Once this critical \\(k_y\\) value is reached, the block’s acceleration remains constant \\(k_y\\), resulting in relative velocity and displacement between block and base. The relative velocity is calculated by integrating the difference between the block and base accelerations. The displacement accumulated by the block moving down the ramp is calculated by integrating the relative velocity. Sliding stops (i.e., block motion again matches base motion exactly) when the relative velocity reaches zero.\n\nDecoupled Analysis\n\nLandslide materials are, of course, not rigid. Except for very shallow, stiff slide masses, the rigid block model does a poor job of approximating the dynamics of a co-seismic landslide system. The decoupled method was developed to provide some way of accounting for the deformation of the slope mass due to shaking (Seed and Martin (1966), Makdisi and Seed (1978)) . It consists of two distinct (or decoupled, if you will) calculations: dynamic response and rigid sliding. During the dynamic response phase, the possibility of sliding is ignored while the slope response to strong ground motion is calculated. The average internal acceleration of the slope mass during this first phase is then used as the base input acceleration for the second phase (rigid sliding) which is simply a rigid block analysis.\n\nCoupled Analysis\n\nAs indicated by the name, coupled analysis takes the two separate calculations from the decoupled analysis and performs them simultaneously. Like the decoupled analysis, the slope mass deforms in response to strong ground motion even before any sliding occurs. Unlike the decoupled method, once the internal average internal acceleration within the slope mass exceeds the yield acceleration, sliding is initiated. During sliding, the acceleration (and therefore the relative velocity and displacement) of the sliding mass above the sliding interface continues to be influenced by the dynamic response of the sliding mass. Sliding stops when the relative velocity of the sliding mass reaches zero. The stop of sliding can introduce an abrupt change in acceleration applied to the sliding mass. Because the dynamic response is being calculated continually through the analysis, the approach to identifying the timing of these abrupt changes will affect the (potential) subsequent sliding events.\n\nDynamic Response\n\nThe Decoupled and Coupled methods both require the calculation of the slope’s dynamic response. The two methods for dynamic response in SLAMMER, which have been carried over to pySLAMMER are linear elastic and equivalent linear.\n\n\n\n\nAnalysis options\nSLAMMER allows users to include a constant \\(k_y\\) value or a variable \\(k_y\\) that changes with accumulated sliding displacement. The \\(k_y\\) – displacement relationship is stepwise with a table of paired values. [purpose]. pySLAMMER includes additional options for variable yield acceleration (as an aside).\nFor the Decoupled and Coupled analysis methods, the dynamic response of the system is calculated. The dynamic response calculation uses either linear elastic or equivalent linear assumptions. The minimum input parameters needed for the linear elastic analyses are [asdf]. For equivalent linear analysis, a reference strain parameter is also needed. Although not explicitly documented, SLAMMER uses XXX modulus reduction and damping.\nSeparate entries for the shear wave velocity of the material above and below the slip surface are used to introduce an equivalent foundation radiation damping into the viscous material damping. This happens behind the scenes in SLAMMER by default and cannot be turned off. However, SLAMMER allows for negative values of damping ratio, which can effectively separate the overall damping behavior from the Vs/Vb. Therefore, we include only soil model, Ts/Tm, damping, and reference strain to characterize the variations in dynamic analysis options",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#results",
    "href": "results_comp_SLAMMER.html#results",
    "title": "Comparison with SLAMMER (results)",
    "section": "Results",
    "text": "Results\nI’d like some static plots and commentary and also a dynamic plot where different dimensions can be explored. Of course, the better the comparison, the more boring this will be.\nI think a good way of showing the comparison would be a table of RMS error by magnitude range. Alternatively, setting an absolute thresheold of “similarity” would work. Or maybe in addition.\n\n\nCode\n# Navigate to ground motion suite response spectra files\ncurrent_dir = os.getcwd()\ndata_path = Path(current_dir).resolve().parents[0] / \"tests\" / \"SLAMMER_results.xlsx\"\n\ndf = import_verification_data(data_path)\ndf[\"kykmax\"] = df[\"ky (g)\"] / df[\"kmax (g)\"]\n\ndfp = df[df[\"kykmax\"] &lt; 1.0]\n\n############\n# pySLAMMER v. SLAMMER\n############\nfig, ax = plt.subplots()\ncmap = plt.cm.viridis  \n\n# Match color values to kykmax values\ncolor_values = dfp[\"kykmax\"] \n\n# Scatter plot with color mapping\nscatter = ax.scatter(\n    dfp[\"SLAMMER\"],  # x-axis values\n    dfp[\"pySLAMMER\"],  # y-axis values\n    c=color_values,  # Numeric values for coloring\n    cmap=cmap,  # Colormap\n    alpha=0.5,  # Transparency\n    marker=\".\",\n)\n\n# Add colorbar\ncbar = plt.colorbar(scatter, ax=ax, alpha=1)\ncbar.set_label(\"Yield Ratio ($k_y/k_{max}$)\")  # Label for the colorbar\n\n\nax.set_xlim(0, 1000)\nax.set_ylim(0, 1000)\n\nplt.grid()\n\nax.set_xlabel(\"SLAMMER displacement (cm)\")\nax.set_ylabel(\"pySLAMMER displacement (cm)\")\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Linear scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the differences are too small to be distinguished visually.\n\n\n\n\n\n\n\nCode\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlim(1e-3, 1e3)\nax.set_ylim(1e-3, 1e3)\n\nfig\n\n\n\n\n\n\n\n\nFigure 3: Log-log scale comparison of pySLAMMER and SLAMMER analysis results. At this scale, the small differences become visible. Nevertheless, the match between the two is excellent in the range of engineering interest.\n\n\n\n\n\n\n\nCode\nscales = [0.001, 0.01, 0.1, 1, 10, 100 ,1000]\ninterest = [\"no\", \"no\", \"yes\", \"yes\", \"yes\", \"yes\"]\nmatch_quality = [\"moderate\", \"very good\", \"excellent\", \"excellent\", \"excellent\", \"excellent\"]\ncomp = {\n    \"Range\": [],\n    \"Engineering\\nInterest\": [],\n    \"Computation\\nMatch\": [],\n    \"error_95\": [],\n    \"Slope\": [],\n    \"Intercept\": [],\n    \"R_sq\": []\n}\n\nfor i in range(len(scales)-1):\n    segment = dfp[\n        (dfp[\"SLAMMER\"] &gt; scales[i])\n        & (dfp[\"SLAMMER\"] &lt; scales[i+1])\n    ]\n    slope, intercept, r, p, se = ssmstat.linregress(\n        segment[\"SLAMMER\"],\n        segment[\"pySLAMMER\"],\n    )\n    comp[\"Range\"].append(f\"{scales[i]} to {scales[i+1]}\")\n    comp[\"Engineering\\nInterest\"].append(interest[i])\n    comp[\"error_95\"].append(f\"{np.percentile(\n        abs(segment[\"pySLAMMER\"] - segment[\"SLAMMER\"]),\n        95):.2f}\")\n    comp[\"Slope\"].append(f\"{slope:.2f}\")\n    comp[\"Intercept\"].append(f\"{intercept:.2f}\")\n    comp[\"R_sq\"].append(f\"{r**2:.2f}\")\n    comp[\"Computation\\nMatch\"].append(match_quality[i])\n    \n\ntbl = (\n    GT(pd.DataFrame(comp))\n    .tab_header(\n    title = \"pySLAMMER-SLAMMER Results Comparison\",\n    subtitle = \"Computational match by order of displacment magnitude\"\n    )\n    .tab_spanner(\n    label=\"Linear Regression Parameters\",\n    columns=[\"Slope\",\"Intercept\",\"R_sq\"]\n    )\n    .cols_label(\n    Range=html(\"Displacement Range&lt;br&gt;(cm)\"),\n    Intercept=html(\"Intercept&lt;br&gt;(cm)\"),\n    R_sq=html(\"R&lt;sup&gt;2&lt;/sup&gt;\"),\n    error_95=html(\"95&lt;sup&gt;th&lt;/sup&gt; percentile error&lt;br&gt;(cm)\")\n\n    )\n)\ntbl\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npySLAMMER-SLAMMER Results Comparison\n\n\nComputational match by order of displacment magnitude\n\n\nDisplacement Range\n(cm)\nEngineering Interest\nComputation Match\n95th percentile error\n(cm)\nLinear Regression Parameters\n\n\nSlope\nIntercept\n(cm)\nR2\n\n\n\n\n0.001 to 0.01\nno\nmoderate\n0.01\n1.06\n0.00\n0.54\n\n\n0.01 to 0.1\nno\nvery good\n0.01\n1.00\n0.00\n0.99\n\n\n0.1 to 1\nyes\nexcellent\n0.02\n1.00\n0.00\n1.00\n\n\n1 to 10\nyes\nexcellent\n0.07\n1.00\n0.00\n1.00\n\n\n10 to 100\nyes\nexcellent\n0.27\n1.00\n0.00\n1.00\n\n\n100 to 1000\nyes\nexcellent\n0.67\n1.00\n0.18\n1.00",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#discussion",
    "href": "results_comp_SLAMMER.html#discussion",
    "title": "Comparison with SLAMMER (results)",
    "section": "Discussion",
    "text": "Discussion\nSome differences should be expected.\nTo the extent the pySLAMMER code is doing the same calculations, the differences should be very small.\nThe differences should not accumulate with displacement magnitude.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "results_comp_SLAMMER.html#conclusions",
    "href": "results_comp_SLAMMER.html#conclusions",
    "title": "Comparison with SLAMMER (results)",
    "section": "Conclusions",
    "text": "Conclusions\n\nPySLAMMER is performing the same analysis as SLAMMER.\nNumerical differences are insignificant for engineering purposes, both in research and practice.\nTo the extent historical SLAMMER results are well documented, comparison with pySLAMMER results is appropriate.",
    "crumbs": [
      "Verifications",
      "Comparison with SLAMMER (results)"
    ]
  },
  {
    "objectID": "ground_motion_suite.html",
    "href": "ground_motion_suite.html",
    "title": "Ground motions",
    "section": "",
    "text": "Ground motions\nInsert details of the ground motion suite."
  }
]