{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Rigid and Flexible Anlysis\n",
        "This notebook shows an example use case of pyslammer for running rigid, decoupled, and coupled sliding block analyses.\n",
        "\n",
        "*The next steps assume you've already installed pySLAMMER from PYPI:*\n",
        "```bash\n",
        "    pip install pyslammer\n",
        "```\n",
        "First, import pySLAMMER and a couple other helpful packages\n"
      ],
      "id": "84656ca5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pyslammer as slam\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt"
      ],
      "id": "5246fd1e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next define the ground motion to use in the analysis.\n",
        "For this example, we will use one of pySLAMMER's built in ground motions from the 1995 Kobe earthquake.\n",
        "This creates a ground motion object with `accel` and `dt` attributes with the acceleration array and timestep, respectively.\n"
      ],
      "id": "9f7277d5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "record_name = \"Kobe_1995_TAK-090\"\n",
        "gm = slam.sample_ground_motions()[record_name]"
      ],
      "id": "5a19535e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Rigid block analysis\n",
        "A rigid block analysis requires at least three input parameters:\n",
        "\n",
        "* `a_in` - the input acceleration time history (in units of g)  \n",
        "* `dt` - the timestep separating the acceleration data points  \n",
        "* `ky` - the slope's yield acceleration (in units of g)  \n",
        "\n",
        "These parameters are stored in a dictionary (`rigid_inputs`) and used as kwarg input to the `RigidAnalysis` method.\n"
      ],
      "id": "5836fb18"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "rigid_inputs = {\n",
        "    \"a_in\": gm.accel,\n",
        "    \"dt\": gm.dt,\n",
        "    \"ky\": 0.2\n",
        "}\n",
        "\n",
        "rigid_result = slam.RigidAnalysis(**rigid_inputs)"
      ],
      "id": "b797e097",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Flexible sliding block analysis\n",
        "The flexible block analyses (decoupled and coupled) require additional input parameters to define the stiffness of the model:\n",
        "* `height` - the slope height (in meters, by default)\n",
        "* `vs_slope` - the slope shear wave velocity  (in meters per second, by default)\n",
        "* `vs_base` - the base shear wave velocity (in meters per second, by default)\n",
        "* `damp_ratio` - the slope damping ratio\n",
        "* `ref_strain` - the slope reference strain\n",
        "* `soil_model` - the dynamic analysis method used (either `linear_elastic` or `equivalent_linear`)\n",
        "\n",
        "\n",
        "These parameters are stored in a dictionary (`flexible_inputs`) and used as kwargs along with those used in the rigid analysis.\n",
        "The decoupled and coupled analyses are run with the `Decoupled` and `Coupled` methods, respectively.\n"
      ],
      "id": "cd4e8970"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "flexible_inputs = {\n",
        "    \"height\": 50.0,\n",
        "    \"vs_slope\": 600.0,\n",
        "    \"vs_base\": 600.0,\n",
        "    \"damp_ratio\": 0.05,\n",
        "    \"ref_strain\": 0.0005,\n",
        "    \"soil_model\": \"equivalent_linear\"\n",
        "}\n",
        "\n",
        "decoupled_result = slam.Decoupled(**rigid_inputs,**flexible_inputs)\n",
        "decoupled_result._compile_attributes()\n",
        "coupled_result = slam.Coupled(**rigid_inputs,**flexible_inputs)\n",
        "coupled_result._compile_attributes()"
      ],
      "id": "96d71eab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Comparison of analysis methods\n",
        "A simple plot comparing the block displecements with time can be generated by accessing the `.sliding_disp` attribute of each analysis result."
      ],
      "id": "8eb7d2a5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(10, 6))\n",
        "\n",
        "time = np.arange(0, len(gm.accel) * gm.dt, gm.dt)\n",
        "\n",
        "# Plot block displacement vs time for each analysis method\n",
        "plt.plot(time, rigid_result.sliding_disp, label='Rigid Analysis')\n",
        "plt.plot(time, decoupled_result.sliding_disp, label='Decoupled Analysis')\n",
        "plt.plot(time, coupled_result.sliding_disp, label='Coupled Analysis')\n",
        "\n",
        "# Add labels and legend\n",
        "plt.xlabel('Time (s)')\n",
        "plt.ylabel('Block Displacement (m)')\n",
        "plt.title(f'Block Displacement with Different Analysis Methods\\n for {record_name}')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "\n",
        "# Show the plot\n",
        "plt.show()"
      ],
      "id": "47096f02",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Library/Frameworks/Python.framework/Versions/3.12/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}