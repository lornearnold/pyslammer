---
page-navigation: true
---
```{python}
#| echo: false
from pathlib import Path
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import pyslammer as slam
import scipy.stats.mstats as ssmstat
from cycler import cycler
from tests.verification_processes import import_verification_data
%matplotlib widget
plt.style.use(slam.psfigstyle)
```
# Comparison with SLAMMER (results)

PySLAMMER's rigid, decoupled, and coupled analysis methods are intended to produce sliding block analysis results that match the legacy SLAMMER results. This is an important feature for sliding block displacements, which are used as a performance index (as opposed to providing a direct prediction of actual slope displacement) in practice. Equivalence with legacy results allows new results to be interpreted with reference to historical analyses and experience.

## Approach

To demonstrate pySLAMMER's equivalence to SLAMMER, we performed several sliding block analyses across a broad parametric space. The three main categories of parameters studied were ground motion, analysis method, and analysis options.

### Ground motion

A wide range of motions and scalings were used to capture a reasonable breadth of the familiar key engineering ground motion characteristics (frequency, amplitude, and duration). We used all the motions in pySLAMMER's built-in sample ground motion suite (which are also all included in SLAMMER) to compare the two programs. The spectral accelerations are shown in Figure 1. Table 1 shows the duration (Dobry) and mean period (Rathje) of the ground motion suite. The motion suite was scaled to provide ky/kmax values from 0.05 to 1.0. 

```{python}
#| code-fold: true
#| fig-align: center
# Navigate to ground motion suite response spectra files
current_dir = os.getcwd()
folder_path = Path(current_dir).resolve().parents[0] / "tests" / "pySLAMMER_suite_resp"
csv_files = list(folder_path.glob("*.csv"))

# Read each CSV file into a DataFrame and store them in a list
freq_index = 0
resp_index = 1
spectra = {}
for csv_file in csv_files:
    data = np.loadtxt(csv_file, delimiter=",", skiprows=2)
    # convert response from cm/s^2 to g's
    data[:, resp_index] = data[:, resp_index] / 981
    spectra[csv_file.name.strip(".csv")] = data

# Initialize the plot
fig, ax = plt.subplots()
# fig.set_size_inches(7,5)
ax.set_prop_cycle(cycler(color=plt.cm.tab20.colors))
for motion in spectra:
    ax.plot(
        1/spectra[motion][:, freq_index],
        spectra[motion][:, resp_index],
        label=motion,
        linewidth=0.5,
    )

ax.text(0.012, 2.75, "5% damping")
# Add labels, legend, and grid
ax.set_xlabel("Period (s)")
ax.set_ylabel("Spectral Acceleration (g)")
ax.set_title("Response Spectra")
ax.set_xscale("log")
ax.set_ylim(0,3)
ax.set_xlim(0.01,100)

# ax.ticklabel_format(style="plain")
ax.legend(
    loc="center left", 
    bbox_to_anchor=(0.6, 0.6), 
    fontsize="x-small", 
    title="Ground Motion", 
    title_fontsize="medium",
    frameon=False
)

# Show the plot
plt.show()
```

### Analysis methods

The three rigorous analysis methods that SLAMMER performs are the Rigid, Decoupled, and Coupled methods. [brief explanation of each]. Each of these methods are implemented in pySLAMMER and included in this comparison.

### Analysis options

SLAMMER allows users to include a constant $k_y$ value or a variable $k_y$ that changes with accumulated sliding displacement. The $k_y$ -- displacement relationship is stepwise with a table of paired values. [purpose]. pySLAMMER includes additional options for variable yield acceleration (as an aside).

For the Decoupled and Coupled analysis methods, the dynamic response of the system is calculated. The dynamic response calculation uses either *linear elastic* or *equivalent linear* assumptions. The minimum input parameters needed for the linear elastic analyses are [asdf]. For equivalent linear analysis, a reference strain parameter is also needed. Although not explicitly documented, SLAMMER uses XXX modulus reduction and damping.

Separate entries for the shear wave velocity of the material above and below the slip surface are used to introduce an equivalent foundation radiation damping into the viscous material damping. This happens behind the scenes in SLAMMER by default and cannot be turned off. However, SLAMMER allows for negative values of damping ratio, which can effectively separate the overall damping behavior from the Vs/Vb. Therefore, we include only soil model, Ts/Tm, damping, and reference strain to characterize the variations in dynamic analysis options

## Results

I'd like some static plots and commentary and also a dynamic plot where different dimensions can be explored. Of course, the better the comparison, the more boring this will be.

I think a good way of showing the comparison would be a table of RMS error by magnitude range. Alternatively, setting an absolute thresheold of "similarity" would work. Or maybe in addition.

```{python}
#| code-fold: true
#| fig-align: center

# Navigate to ground motion suite response spectra files
current_dir = os.getcwd()
data_path = Path(current_dir).resolve().parents[0] / "tests" / "SLAMMER_results.xlsx"

df = import_verification_data(data_path)
df["kykmax"] = df["ky (g)"] / df["kmax (g)"]

dfp = df[df["kykmax"] < 1.0]

############
# pySLAMMER v. SLAMMER
############
fig, ax = plt.subplots()
cmap = plt.cm.viridis  # You can use other colormaps like 'plasma', 'coolwarm', etc.

# Define the numeric values for coloring (e.g., SLAMMER values)
color_values = dfp["kykmax"] # Replace with the column you want to use for coloring

# Scatter plot with color mapping
scatter = ax.scatter(
    dfp["SLAMMER"],  # x-axis values
    dfp["pySLAMMER"],  # y-axis values # abs(dfp["SLAMMER"] - dfp["pySLAMMER"]) / dfp["pySLAMMER"],  # y-axis values
    c=color_values,  # Numeric values for coloring
    cmap=cmap,  # Colormap
    alpha=0.5,  # Transparency
    marker=".",
)

# Add a colorbar
cbar = plt.colorbar(scatter, ax=ax, alpha=1)
cbar.set_label("Yield Ratio ($k_y/k_{max}$)")  # Label for the colorbar

log = False
if not log:
    ax.set_xlim(0, 1000)
    ax.set_ylim(0, 1000)

else:
    ax.set_xscale("log")
    ax.set_yscale("log")
    ax.set_xlim(1e-3, 1e3)
    ax.set_ylim(1e-3, 1e3)


# ax.set_aspect('equal', adjustable='box')

plt.grid()

# plt.legend(loc='upper right', bbox_to_anchor=(0.2, 1))
plt.legend()

plt.xlabel("SLAMMER displacement (cm)")
plt.ylabel("pySLAMMER displacement (cm)")
plt.title("Comparison of pySLAMMER and SLAMMER results")
plt.show()
```

```{python}
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_xlim(1e-3, 1e3)
ax.set_ylim(1e-3, 1e3)

plt.show()
```

```{python}
comp = {
    "Range": [],
    "Engineering\nInterest": [],
    "Computation\nMatch": [],
    "Slope": [],
    "Intercept": [],
    "R$^2$": [],
    "95th percentile\nerror": []
}

for i in range(len(scales)-1):
    segment = dfp[
        (dfp["SLAMMER"] > scales[i])
        & (dfp["SLAMMER"] < scales[i+1])
    ]
    slope, intercept, r, p, se = ssmstat.linregress(
        segment["SLAMMER"],
        segment["pySLAMMER"],
    )
    comp["Range"].append(f"{scales[i]} to {scales[i+1]} cm")
    comp["Engineering\nInterest"].append(interest[i])
    comp["Computation\nMatch"].append(match[i])
    comp["Slope"].append(f"{slope:.2f}")
    comp["Intercept"].append(f"{intercept:.2f}")
    comp["R$^2$"].append(f"{r**2:.2f}")
    comp["95th percentile\nerror"].append(f"{np.percentile(
        abs(segment["pySLAMMER"] - segment["SLAMMER"]),
        95):.2f}")
```
## Discussion
Some differences should be expected. 

To the extent the pySLAMMER code is doing the same calculations, the differences should be very small.

The differences should not accumulate with displacement magnitude.

## Conclusions
1. PySLAMMER is performing the same analysis as SLAMMER.
2. Numerical differences are insignificant for engineering purposes, both in research and practice.
3. To the extent historical SLAMMER results are well documented, comparison with pySLAMMER results is appropriate.
